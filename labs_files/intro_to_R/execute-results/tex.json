{
  "hash": "0e8b106d77a77c3aec8b2c807035a235",
  "result": {
    "engine": "knitr",
    "markdown": "# A brief R tutorial {.unnumbered}\n\nIf you are new to **R** you can have a short dive into its main features by working through this tutorial. If you had learnt programming in another computer language, you will be able to skim over this tutorial to find the main differences from what you have learnt to how things are done in **R.**\n\n## Variables, vectors and matrices\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Introduction to variables\n# Variables can be any sequence of letter and numbers, but \n# it cannot start with a number\nx = 2\nx <- 4\n2+2 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- x^5\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1024\n```\n\n\n:::\n\n```{.r .cell-code}\n# Introduction to vectors\nv1 <- c(2,3,6,12)\nv2 <- 1:100\nlength(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\nv2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n```\n\n\n:::\n\n```{.r .cell-code}\nv3 <- seq(1,100,5)  # call without naming arguments\nv3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96\n```\n\n\n:::\n\n```{.r .cell-code}\nv3 <- seq(from=1,to=100,by=5) # call with names of arguments\nv3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96\n```\n\n\n:::\n\n```{.r .cell-code}\nv3 <- seq(to=100,by=5) # call skipping the first argument\n#and using the default value 1 - see help(seq)\nv3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96\n```\n\n\n:::\n\n```{.r .cell-code}\nv3 <- seq(by=5,to=100) # call by arguments and change order or arguments\n\n# Indexing vectors\nv3[3] #uses square brackets to obtain the third element of the vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nv3>20 # produce a vector of boolean values that are TRUE when\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n      #v3 is greater than 20\nv3[v3>20] # select from v3 all the values that are greater than 20\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96\n```\n\n\n:::\n\n```{.r .cell-code}\nv4<-c(1,2,3,4,5)\nv4[c(FALSE,TRUE,FALSE,TRUE,FALSE)] #select from v4 the second and fourth element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\nv3[1:10] # first ten elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  6 11 16 21 26 31 36 41 46\n```\n\n\n:::\n\n```{.r .cell-code}\nv3[-1] # dropping first element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(v2) # prints the first few elements of v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(v2) # prints the last few elements of v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  95  96  97  98  99 100\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich(v3 == 26) # returns the position of v3 that equals 26\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n#Numerical operations with vectors\n2^v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 2.000000e+00 4.000000e+00 8.000000e+00 1.600000e+01 3.200000e+01\n  [6] 6.400000e+01 1.280000e+02 2.560000e+02 5.120000e+02 1.024000e+03\n [11] 2.048000e+03 4.096000e+03 8.192000e+03 1.638400e+04 3.276800e+04\n [16] 6.553600e+04 1.310720e+05 2.621440e+05 5.242880e+05 1.048576e+06\n [21] 2.097152e+06 4.194304e+06 8.388608e+06 1.677722e+07 3.355443e+07\n [26] 6.710886e+07 1.342177e+08 2.684355e+08 5.368709e+08 1.073742e+09\n [31] 2.147484e+09 4.294967e+09 8.589935e+09 1.717987e+10 3.435974e+10\n [36] 6.871948e+10 1.374390e+11 2.748779e+11 5.497558e+11 1.099512e+12\n [41] 2.199023e+12 4.398047e+12 8.796093e+12 1.759219e+13 3.518437e+13\n [46] 7.036874e+13 1.407375e+14 2.814750e+14 5.629500e+14 1.125900e+15\n [51] 2.251800e+15 4.503600e+15 9.007199e+15 1.801440e+16 3.602880e+16\n [56] 7.205759e+16 1.441152e+17 2.882304e+17 5.764608e+17 1.152922e+18\n [61] 2.305843e+18 4.611686e+18 9.223372e+18 1.844674e+19 3.689349e+19\n [66] 7.378698e+19 1.475740e+20 2.951479e+20 5.902958e+20 1.180592e+21\n [71] 2.361183e+21 4.722366e+21 9.444733e+21 1.888947e+22 3.777893e+22\n [76] 7.555786e+22 1.511157e+23 3.022315e+23 6.044629e+23 1.208926e+24\n [81] 2.417852e+24 4.835703e+24 9.671407e+24 1.934281e+25 3.868563e+25\n [86] 7.737125e+25 1.547425e+26 3.094850e+26 6.189700e+26 1.237940e+27\n [91] 2.475880e+27 4.951760e+27 9.903520e+27 1.980704e+28 3.961408e+28\n [96] 7.922816e+28 1.584563e+29 3.169127e+29 6.338253e+29 1.267651e+30\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n  [8] 2.0794415 2.1972246 2.3025851 2.3978953 2.4849066 2.5649494 2.6390573\n [15] 2.7080502 2.7725887 2.8332133 2.8903718 2.9444390 2.9957323 3.0445224\n [22] 3.0910425 3.1354942 3.1780538 3.2188758 3.2580965 3.2958369 3.3322045\n [29] 3.3672958 3.4011974 3.4339872 3.4657359 3.4965076 3.5263605 3.5553481\n [36] 3.5835189 3.6109179 3.6375862 3.6635616 3.6888795 3.7135721 3.7376696\n [43] 3.7612001 3.7841896 3.8066625 3.8286414 3.8501476 3.8712010 3.8918203\n [50] 3.9120230 3.9318256 3.9512437 3.9702919 3.9889840 4.0073332 4.0253517\n [57] 4.0430513 4.0604430 4.0775374 4.0943446 4.1108739 4.1271344 4.1431347\n [64] 4.1588831 4.1743873 4.1896547 4.2046926 4.2195077 4.2341065 4.2484952\n [71] 4.2626799 4.2766661 4.2904594 4.3040651 4.3174881 4.3307333 4.3438054\n [78] 4.3567088 4.3694479 4.3820266 4.3944492 4.4067192 4.4188406 4.4308168\n [85] 4.4426513 4.4543473 4.4659081 4.4773368 4.4886364 4.4998097 4.5108595\n [92] 4.5217886 4.5325995 4.5432948 4.5538769 4.5643482 4.5747110 4.5849675\n [99] 4.5951199 4.6051702\n```\n\n\n:::\n\n```{.r .cell-code}\nv5 <- 101:200\nv5-v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n [19] 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n [37] 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n [55] 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n [73] 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n [91] 100 100 100 100 100 100 100 100 100 100\n```\n\n\n:::\n\n```{.r .cell-code}\nv5/v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 101.000000  51.000000  34.333333  26.000000  21.000000  17.666667\n  [7]  15.285714  13.500000  12.111111  11.000000  10.090909   9.333333\n [13]   8.692308   8.142857   7.666667   7.250000   6.882353   6.555556\n [19]   6.263158   6.000000   5.761905   5.545455   5.347826   5.166667\n [25]   5.000000   4.846154   4.703704   4.571429   4.448276   4.333333\n [31]   4.225806   4.125000   4.030303   3.941176   3.857143   3.777778\n [37]   3.702703   3.631579   3.564103   3.500000   3.439024   3.380952\n [43]   3.325581   3.272727   3.222222   3.173913   3.127660   3.083333\n [49]   3.040816   3.000000   2.960784   2.923077   2.886792   2.851852\n [55]   2.818182   2.785714   2.754386   2.724138   2.694915   2.666667\n [61]   2.639344   2.612903   2.587302   2.562500   2.538462   2.515152\n [67]   2.492537   2.470588   2.449275   2.428571   2.408451   2.388889\n [73]   2.369863   2.351351   2.333333   2.315789   2.298701   2.282051\n [79]   2.265823   2.250000   2.234568   2.219512   2.204819   2.190476\n [85]   2.176471   2.162791   2.149425   2.136364   2.123596   2.111111\n [91]   2.098901   2.086957   2.075269   2.063830   2.052632   2.041667\n [97]   2.030928   2.020408   2.010101   2.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nv1/v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 2.00000000 1.50000000 2.00000000 3.00000000 0.40000000 0.50000000\n  [7] 0.85714286 1.50000000 0.22222222 0.30000000 0.54545455 1.00000000\n [13] 0.15384615 0.21428571 0.40000000 0.75000000 0.11764706 0.16666667\n [19] 0.31578947 0.60000000 0.09523810 0.13636364 0.26086957 0.50000000\n [25] 0.08000000 0.11538462 0.22222222 0.42857143 0.06896552 0.10000000\n [31] 0.19354839 0.37500000 0.06060606 0.08823529 0.17142857 0.33333333\n [37] 0.05405405 0.07894737 0.15384615 0.30000000 0.04878049 0.07142857\n [43] 0.13953488 0.27272727 0.04444444 0.06521739 0.12765957 0.25000000\n [49] 0.04081633 0.06000000 0.11764706 0.23076923 0.03773585 0.05555556\n [55] 0.10909091 0.21428571 0.03508772 0.05172414 0.10169492 0.20000000\n [61] 0.03278689 0.04838710 0.09523810 0.18750000 0.03076923 0.04545455\n [67] 0.08955224 0.17647059 0.02898551 0.04285714 0.08450704 0.16666667\n [73] 0.02739726 0.04054054 0.08000000 0.15789474 0.02597403 0.03846154\n [79] 0.07594937 0.15000000 0.02469136 0.03658537 0.07228916 0.14285714\n [85] 0.02352941 0.03488372 0.06896552 0.13636364 0.02247191 0.03333333\n [91] 0.06593407 0.13043478 0.02150538 0.03191489 0.06315789 0.12500000\n [97] 0.02061856 0.03061224 0.06060606 0.12000000\n```\n\n\n:::\n\n```{.r .cell-code}\n#Using strings in R\nmystring <- \"Ecology\"\nvstrg <- c(\"Anna\", \"Peter\", \"Xavier\")\nvstrg[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Peter\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#making plots in R\nplot(v2,v2)\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-1-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(v2,v2^2)\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-1-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(v2,v2^2,type=\"l\")\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-1-3.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(v2,v2^2,type=\"l\",col=\"red\")\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-1-4.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(v2,v2^2,type=\"l\",col=\"red\",main=\"My beautiful plot\")\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-1-5.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(v2,v2^2,type=\"l\",col=\"red\",main=\"My beautiful plot\",xlab=\"x\",\n     ylab=\"x^2\")\nlines(v2,v2^3,col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-1-6.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Matrices in R\nm <- matrix(5,3,2)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    5\n[2,]    5    5\n[3,]    5    5\n```\n\n\n:::\n\n```{.r .cell-code}\nm2 <- matrix(1:6,3,2)\nm2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\nt(m2) # transposes matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- 1:4\ny <- 5:8\n\nm3<-cbind(x,y)\nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     x y\n[1,] 1 5\n[2,] 2 6\n[3,] 3 7\n[4,] 4 8\n```\n\n\n:::\n\n```{.r .cell-code}\nm4<-rbind(x,y)\nm4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4]\nx    1    2    3    4\ny    5    6    7    8\n```\n\n\n:::\n\n```{.r .cell-code}\n# Indexing matrices\nm3[3,2] #element in row 3 and column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny \n7 \n```\n\n\n:::\n\n```{.r .cell-code}\nm3[1,] #entire first row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx y \n1 5 \n```\n\n\n:::\n\n```{.r .cell-code}\nm3[,1] #entire first column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(m3)<-c(\"col1\",\"col2\")\nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n```\n\n\n:::\n\n```{.r .cell-code}\nm3[,\"col2\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# Lists in R\nmylist <- list(elem1=m,elem2=v2,elem3=\"my list\")\nmylist$elem2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n```\n\n\n:::\n\n```{.r .cell-code}\n# Dataframes\ndf <- as.data.frame(m3)\ndf$col1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Iterations and conditional expressions\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# FOR loops\n\nfor (k in 1:10)  # for k =1, 2, 3, 4, 5,...10\n  print (k^2)   #do this\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n[1] 36\n[1] 49\n[1] 64\n[1] 81\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\nR <- 1.2\nn <- 1\nprint(n[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nfor (t in 1:100)\n{\n  n[t+1] <- R*n[t]\n  print(n[t+1])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2\n[1] 1.44\n[1] 1.728\n[1] 2.0736\n[1] 2.48832\n[1] 2.985984\n[1] 3.583181\n[1] 4.299817\n[1] 5.15978\n[1] 6.191736\n[1] 7.430084\n[1] 8.9161\n[1] 10.69932\n[1] 12.83918\n[1] 15.40702\n[1] 18.48843\n[1] 22.18611\n[1] 26.62333\n[1] 31.948\n[1] 38.3376\n[1] 46.00512\n[1] 55.20614\n[1] 66.24737\n[1] 79.49685\n[1] 95.39622\n[1] 114.4755\n[1] 137.3706\n[1] 164.8447\n[1] 197.8136\n[1] 237.3763\n[1] 284.8516\n[1] 341.8219\n[1] 410.1863\n[1] 492.2235\n[1] 590.6682\n[1] 708.8019\n[1] 850.5622\n[1] 1020.675\n[1] 1224.81\n[1] 1469.772\n[1] 1763.726\n[1] 2116.471\n[1] 2539.765\n[1] 3047.718\n[1] 3657.262\n[1] 4388.714\n[1] 5266.457\n[1] 6319.749\n[1] 7583.698\n[1] 9100.438\n[1] 10920.53\n[1] 13104.63\n[1] 15725.56\n[1] 18870.67\n[1] 22644.8\n[1] 27173.76\n[1] 32608.52\n[1] 39130.22\n[1] 46956.26\n[1] 56347.51\n[1] 67617.02\n[1] 81140.42\n[1] 97368.5\n[1] 116842.2\n[1] 140210.6\n[1] 168252.8\n[1] 201903.3\n[1] 242284\n[1] 290740.8\n[1] 348889\n[1] 418666.7\n[1] 502400.1\n[1] 602880.1\n[1] 723456.1\n[1] 868147.4\n[1] 1041777\n[1] 1250132\n[1] 1500159\n[1] 1800190\n[1] 2160228\n[1] 2592274\n[1] 3110729\n[1] 3732875\n[1] 4479450\n[1] 5375340\n[1] 6450408\n[1] 7740489\n[1] 9288587\n[1] 11146304\n[1] 13375565\n[1] 16050678\n[1] 19260814\n[1] 23112977\n[1] 27735572\n[1] 33282687\n[1] 39939224\n[1] 47927069\n[1] 57512482\n[1] 69014979\n[1] 82817975\n```\n\n\n:::\n\n```{.r .cell-code}\nR <- 1.2\nn <- 1\nfor (t in 1:100)\n  n[t+1] <- R*n[t]\n\n# IF conditional statement\n\n# logical operators\n# == equal to\n# > greater than\n# < smaller than\n# >= greater or equal\n# <= smaller or equal\n# != different from\n# && and\n# || or\n\nif (3>2) print (\"yes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"yes\"\n```\n\n\n:::\n\n```{.r .cell-code}\nif (3==2) print (\"yes\") else print(\"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"no\"\n```\n\n\n:::\n\n```{.r .cell-code}\nif ((3>2)&&(4>5)) print (\"yes\")\n\nfor (k in 1:10)  # for k =1, 2, 3, 4, 5,...10\n  if (k^2>20) print (k^2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n[1] 36\n[1] 49\n[1] 64\n[1] 81\n[1] 100\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Writing functions\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creating FUNCTIONS in r\n\npythagoras <- function (c1,c2)\n{\n  h <- sqrt (c1^2 + c2^2)\n  return (h)\n}\n\npythagoras(1,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n\n```{.r .cell-code}\npythagoras(5,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.071068\n```\n\n\n:::\n\n```{.r .cell-code}\npythagoras(10,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.04988\n```\n\n\n:::\n\n```{.r .cell-code}\n# regression in R\n\nhelp(lm)\nx <- c(1,2,3,4)\ny <- c(1.1,2.3,2.9,4.1)\nplot(x,y)\nmyreg<-lm(y ~ x)\nsummary(myreg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    1     2     3     4 \n-0.06  0.18 -0.18  0.06 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)   \n(Intercept)  0.20000    0.23238   0.861  0.48012   \nx            0.96000    0.08485  11.314  0.00772 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1897 on 2 degrees of freedom\nMultiple R-squared:  0.9846,\tAdjusted R-squared:  0.9769 \nF-statistic:   128 on 1 and 2 DF,  p-value: 0.007722\n```\n\n\n:::\n\n```{.r .cell-code}\nabline(myreg)\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n## Random numbers and statistical distributions\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom1d<-function(tmax)\n{\nx<-0\nfor (t in 1:tmax)\n{\n  r<-runif(1)\n  if (r<1/2)\n    x[t+1]<-x[t]+1 else\n      x[t+1]<-x[t]-1\n}\nreturn(x)\n}\n\nplot(random1d(100))\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ntmax<-10000\nlastx<-0\nfor (i in 1:1000)\n{\n  x<-random1d(tmax)\n  lastx[i]<-x[tmax]\n}\n\nhist(lastx)\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-4-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nmean(lastx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2.226\n```\n\n\n:::\n\n```{.r .cell-code}\nd<-sqrt(lastx^2)\nhist(d)\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-4-3.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nmean(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 81.646\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 69\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 377\n```\n\n\n:::\n\n```{.r .cell-code}\nhist(d[d<20],breaks=c(1:20))\n```\n\n::: {.cell-output-display}\n![](intro_to_R_files/figure-pdf/unnamed-chunk-4-4.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n## Spatial analysis\n\n### Shapefiles and Raster (Isabel Rosa)\n\nWhen you work with spatial data, essentially you use two types of data:\n\n1)  vector data (i.e., shapefiles): stores the geometric location and attribute information of geographic features. These can be represented by points, lines, or polygons (areas).\n2)  matricial data (i.e., raster): consists of a matrix of cells (or pixels) organized into rows and columns (or a grid) where each cell contains a value representing information. They can be categorical or continuous and have multiple bands.\n\nFor more information on the tree cover datasets, please see: <https://earthenginepartners.appspot.com/science-2013-global-forest/download_v1.2.html>\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in shapefile using rgdal\nsc <- readOGR(\".\", \"SantaCatarina\")\n\n# import municipalities and settlements shapefiles\nsc_mun <- readOGR(\".\", \"SantaCatarina_mun\")\nbr_sett <- readOGR(\".\", \"Brazil_settlements\")\n\n# always good to check the contents of your dat\n#str(br_sett)\n\n# visualize one of the variables\nspplot(sc_mun, z=\"Shape_Area\", main = \"Municipality Area (km2)\")\n\n# read in raster\ntc<-raster(\"tree_cover.tif\")\n\n# import loss and gain rasters here\ntl<-raster(\"loss.tif\")\ntg<-raster(\"gain.tif\")\n\n# for multiple band rasters, you can choose to import just one or all bands\n#r2 <- raster(\"tree_cover_multi.tif\", band=2)\n\n# note that the value 255, which is Hansen's nodata value was not recognized as such\nNAvalue(tg) # check first\nNAvalue(tc)<-255 #fix it by forcing 255 to be the nodata\nNAvalue(tl)<-255 #fix it by forcing 255 to be the nodata\nNAvalue(tg)<-255 #fix it by forcing 255 to be the nodata\n\n# visualize one of the rasters\npar(mfrow=c(1,3))\nplot(tc, main = \"Tree Cover (%)\")\nplot(tl, main = \"Tree Cover Loss (binary)\")\nplot(tg, main = \"Tree Cover Gain (binary)\")\n```\n:::\n\n\n\n\n\n\n### Reference systems\n\nCoordinate systems are essential to understand when working with spatial data. Some reading material on this can be found here: Essentially, if one wants to know which position of the Earth we refer to, coordinates of geospatial data require a reference system:\n\n1)  geodesic/geographic coordinates need an order (lat/long), a unit (e.g., degrees) and a datum (a reference ellipsoid: e.g. WGS84)\n2)  cartesian/projected coordinates (e.g. UTM, web Mercator) need also measurement units (e.g., meters), and some way of encoding how they relate to geodesic coordinates, in which datum (this is handled by the GIS system)\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n### Operations with Shapefiles\n\nClip: in R you can clip using the command \"intersect\", so that intersect(feature to be clipped, clip feature) Select: you can use a boolean selection to subset the features of your shapefile, for instance if you just want to look at settlements with a mininum number of habitants, so that Population \\> median(Population) There are several options, have a look at this great tutorial: <http://www.rspatial.org/spatial/rst/7-vectmanip.html>\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clip the settlement features using the Santa Catarina shapefile\nsc_sett<-intersect(br_sett, sc)\n\n#sc_sett$med <- sc_sett$population > median(sc_sett$population) # oops! annoyingly our population values have been stored as factors\n\n# convert to original numerical values\nsc_sett$population<-as.numeric(as.vector(sc_sett$population))\n# careful! applying as.numeric alone it will not work!!\n\n# visualize results\nplot(sc_sett, main = \"Settlements in Santa Catarina\")\nspplot(sc_sett, z=\"population\", main = \"Population per Settlement (people)\")\n\n# select settlements larger then the median value\nsc_sett$med <- sc_sett$population > median(sc_sett$population)\nsc_largesett <- sc_sett[sc_sett$med == 1, ]\n\n# visualize results\npar(mfrow=c(1,2))\nplot(sc_sett, main = \"All Settlements\")\nplot(sc_largesett, main = \"Largest Settlements\")\n```\n:::\n\n\n\n\n\n\n### Operations with Rasters\n\nThere are many operations you can do with rasters, and these are more frequently used in spatial analyses than shapefiles. Here I will just illustrate a couple of simple operations: - Global/Raster statistics - obtain a value that summarizes the whole raster layer - Cell statistics (pixel-by-pixel operation): obtains a value per pixel - Focal statistics (operation that takes into account neighborhood of central cell) - results in raster of same of different size - Zonal statistics - calculates summary statistics of a give raster (e.g., elevation) based on pre-defined zones (e.g., admnistrative boundaries, biomes). Outputs a table with the values per zone. For more great examples, have a look here: <http://www.rspatial.org/spatial/rst/8-rastermanip.html>\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sum the loss and gain rasters to know where there was simultaneous loss and gain in Santa Catarina\ntclg<-tl+tg \npar(mfrow=c(1,3))\nplot(tl, main = \"Forest Loss\")\nplot(tg, main = \"Forest Gain\")\nplot(tclg, main = \"Forest Loss and Gain\")\n\n# you can also try to create three new rasters and work with them\n# create a new raster\nr <- raster(ncol=10, nrow=10, xmx=-80, xmn=-150, ymn=20, ymx=60)\nvalues(r) <- runif(ncell(r)) # assign random values\n#plot(r)\n\n# create two more rasters based on the first one\nr2 <- r * r\nr3  <- sqrt(r)\n\n# either stack or brick them\ns <- stack(r, r2, r3)\n#b <- brick(s)\n\n# Raster statistics - calculate several statistics per raster layer (i.e., sum, mean, median)\ncellStats(s, \"sum\") # outputs a value per raster\n\n# Cell statistics - calculate several statistics per pixel  (i.e., sum, mean, median)\npar(mfrow=c(2,2))\nplot(r, main =\"Random 1\")\nplot(r2, main =\"Random 2\")\nplot(r3, main =\"Random 3\")\nplot(overlay(s, fun=\"mean\"), main=\"Average Values\") # outputs a new raster\n\n# Focal statistics - calculate mean accounting for the neighborhood values, compare with previous outcome \nf1 <- focal(tc, w=matrix(1,nrow=5,ncol=5) , fun=mean)\nplot(f1, main = \"Average forest cover 5x5\")\n# sum the loss, vary window size\nf2 <- focal(tl, w=matrix(1,nrow=5,ncol=5) , fun=sum)\nplot(f2, main = \"Total forest loss 5x5\")\n# sum the gain, vary window size\nf3 <- focal(tg, w=matrix(1,nrow=5,ncol=5) , fun=sum)\nplot(f3, main = \"Total forest gain 5x5\")\n\n# plot 4 maps with different window sizes\npar(mfrow=c(2,2))\nfor(i in c(5,15,25,55)){\n  f_w <- focal(tc, w=matrix(1,nrow=i,ncol=i) , fun=sum)\n  plot(f_w, main = paste0(\"Window size: \", i))\n}\n\n# Zonal Statistics - using two rasters\nsc_tc_mean_loss <- zonal(tc, tl, fun=mean) #average tree cover in loss areas\nsc_tc_mean_gain <- zonal(tc, tg, fun=mean) #average tree cover in gain areas\n\n# average tree cover loss\nsc_tc_mean_loss\n\n# average tree cover gain\nsc_tc_mean_gain\n```\n:::\n\n\n\n\n\n\n### Operations with both Rasters and Shapefiles\n\nHere I'll show a couple of examples of operation that use feature data as inputs and output rasters: Distance to features - calculates the euclidean distance from each cell/pixel to the closest feature (e.g., roads, settlements). Outputs a raster file with these distances. Interpolation: a world in itself! Very vey short example provided here (based on a single method, IDW), please see more here: <http://www.rspatial.org/analysis/rst/4-interpolation.html> To better understand interpolation I advise you to read first about spatial autocorrelation: <http://www.rspatial.org/analysis/rst/3-spauto.html>\n\nTo use interpolation metrics you need to load another packaged called gstat Inverse distance weighted (IDW) - See more also here: <http://desktop.arcgis.com/en/arcmap/10.3/tools/3d-analyst-toolbox/how-idw-works.htm>\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create an empty raster (little trick using existing raster)\ndist_sett<-tc*0\n# or you can create an empty one like before\n# dist_sett <- raster(ncol=ncol(tc), nrow=nrow(tc), xmx=extent(tc)@xmax, xmn=extent(tc)@xmin, ymn=extent(tc)@ymin, ymx=extent(tc)@ymax)\n\n# Distance to points\ndist_sett <- distanceFromPoints(dist_sett, sc_sett)\n\n# you can then mask the outside area of Santa Catarina\ndist_sett <- mask(dist_sett, tc)\n\n# plot results\nplot(dist_sett, main = \"Distance to settlements (m)\")\n\n# load gstat\nlibrary(gstat)\nidw_sett<-tc*0\n\n# compute the model, see reference for more detail\ngs <- gstat(formula=population~1, locations=sc_sett, nmax=5, set=list(idp = 2))\nidw_out <- interpolate(idw_sett, gs)\n\n## [inverse distance weighted interpolation]\nsc_pop <- mask(idw_out, tc)\nplot(sc_pop, main = \"Santa Catarina Population\")\n```\n:::\n\n\n\n\n\n\n### Export Shapefiles and Rasters\n\nIt's very easy to export both shapefiles and rasters from R to be visualized in QGIS or ArcMap.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save feature layers (point, polygon, polyline) to shapefile \nwriteOGR(sc_largesett, dsn=\".\", layer=\"SC_largeSett\", driver=\"ESRI Shapefile\" )\n\n# or \n#shapefile(sc_largesett, \"SC_largeSett.shp\", overwrite=TRUE) \n\n#Exporting raster\nwriteRaster(sc_pop, filename=\"SC_popmap\", format=\"GTiff\" )\n```\n:::\n\n\n\n\n\n\n## Working with biodiversity data: GBIF, EBV Portal (Corey Callaghan, Luise Quoss)First we load the library rgbif.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgbif)\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n\n\nNow we will download observations of a species. Let's download observations of the common toad \"Bufo bufo\".\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatbufobufo<-occ_search(scientificName=\"Bufo bufo\", limit=500, hasCoordinate = TRUE, hasGeospatialIssue = FALSE)\n```\n:::\n\n\n\n\n\n\nLet's examine the object *matbufobufo*\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(matbufobufo)\nmatbufobufo\n```\n:::\n\n\n\n\n\n\nLet's download data about octupusses. They are in the order \"Octopoda\". First we need to find the GBIF search key for Octopoda.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na<-name_suggest(q=\"Octopoda\",rank=\"Order\")\nkey<-a$data$key\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noctopusses<-occ_search(orderKey=key,limit=2000, hasCoordinate = TRUE, hasGeospatialIssue = FALSE)\n```\n:::\n\n\n\n\n\n\nShow the result\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noctmat<-octopusses$data\nhead(octmat)\n```\n:::\n\n\n\n\n\n\nCount the number of observations per species using tidyverse and pipes\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#class(octmat)\noctmat %>% \n  group_by(scientificName) %>% \n  summarise(sample_size=n()) %>%\n  arrange(desc(sample_size)) %>% \n  mutate(sample_size_log=log(sample_size,2)) %>% \n  ggplot(aes(x = sample_size_log)) + geom_histogram() \n```\n:::\n\n\n\n\n\n\nPlot the records on an interactive map. First load the leaflet package.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaflet)\nleaflet(data=octmat) %>% addTiles() %>%\n  addCircleMarkers(lat= ~decimalLatitude, lng = ~decimalLongitude,popup=~scientificName)\n```\n:::\n\n\n\n\n\n\n### Version 2 (Isabel Rosa)\n\nHere are the packages we'll need.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgbif)\nlibrary(tidyverse)\nlibrary(raster)\nlibrary(maps)\nlibrary(leaflet)\nlibrary(sdmpredictors)\n```\n:::\n\n\n\n\n\n\nFirst let's pick an example species to download data for. We will only download 500 observations to keep it simple for now. If you were doing this for real, you would download all data for that species (see notes at the end). I will choose the European Robin: <https://en.wikipedia.org/wiki/European_robin.>\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- occ_search(scientificName=\"Erithacus rubecula\", limit=500, hasCoordinate = TRUE, hasGeospatialIssue=FALSE)\n```\n:::\n\n\n\n\n\n\nWhat does this object look like?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(species)\n\nspecies\n```\n:::\n\n\n\n\n\n\nIt is a special object of class `gbif` which allows for the metadata and the actual data to all be included, as well as taxonomic hierarchy data, and media metadata. We won't worry too much about the details of this object now. But we do want to get a dataframe we can work with! To do this, we have one extra step.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_dat <- species$data\n\nclass(sp_dat)\n\nhead(sp_dat)\n```\n:::\n\n\n\n\n\n\nSo this was just for one species. Lets broaden this out a little bit. What if we were interested in many species of a given order/class? Here, we will choose an entire order to download. I will choose owls! <https://en.wikipedia.org/wiki/Owl.> First, we need to find the 'key' that gbif uses for that order and then pass it to our GBIF download function. Again, we are only getting a small number of records for illustration purposes.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- name_suggest(q='Strigiformes')\n\nkey <- a$data$key\n\norder <- occ_search(orderKey=key, limit=1000, hasCoordinate = TRUE, hasGeospatialIssue=FALSE) \n```\n:::\n\n\n\n\n\n\nWhat kind of object is 'order'? As with species, we need to turn it into a dataframe to work with.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder_dat <- order$data\n\nclass(order_dat)\n\nhead(order_dat)\n```\n:::\n\n\n\n\n\n\nCount the number of observations by species\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder_dat %>%\n  group_by(scientificName) %>%\n  summarize(sample_size=n()) %>%\n  arrange(desc(sample_size))\n```\n:::\n\n\n\n\n\n\nPlot the records on an interactive map. First for our chosen species.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = sp_dat) %>%\n    addTiles() %>%\n    addCircleMarkers(lat = ~decimalLatitude, lng = ~decimalLongitude,popup = ~scientificName)\n```\n:::\n\n\n\n\n\n\nThen for the order we chose.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = order_dat) %>%\n    addTiles() %>%\n    addCircleMarkers(lat = ~decimalLatitude, lng = ~decimalLongitude, popup = ~scientificName)\n```\n:::\n\n\n\n\n\n\n## Climate data\n\nLet's play with some global climate data and overlay that with our GBIF observations.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_temp_map <- getData(name=\"worldclim\", res=10, var=\"tmean\")\nplot(mean_temp_map)\n```\n:::\n\n\n\n\n\n\nEach month has separate values for each cell. To combine to a yearly value, we just take the mean.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nannual_mean_temp <- mean(mean_temp_map)/10 #data comes as degrees * 10\n```\n:::\n\n\n\n\n\n\nNow plot this.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(annual_mean_temp)\n```\n:::\n\n\n\n\n\n\nTo get out the values for the organism of interest, we use `extract`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\norg_temp <- extract(annual_mean_temp, cbind(x=sp_dat$decimalLongitude, y=sp_dat$decimalLatitude))\n```\n:::\n\n\n\n\n\n\nNow we will visualize how the global distribution of temperature values compares with the species' distribution of temperature values. This shows the distribution of temps where robins are found versus the global distribution of temps.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- tibble(mean_temp=getValues(annual_mean_temp)) %>%\n  filter(!is.na(mean_temp))\n\ntemp_org <- tibble(organism_temp=org_temp) %>%\n  filter(!is.na(organism_temp))\n\nggplot(temp, aes(x=mean_temp))+\n  geom_density(fill=\"blue\")+\n  geom_density(data=temp_org, aes(x=organism_temp), fill=\"red\")+\n  theme_bw()\n```\n:::\n\n\n\n\n\n\n## Intro to apply, pipes, ggplot2, tidyverse.\n\n### Introduction to gpplot\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars\nlibrary(ggplot2)\n\nggplot(data=cars, mapping=aes(x=speed,y=dist)) + geom_point(colour=\"red\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(cars$speed,cars$dist)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Introduction to R - 9\n\n\n# a recursive function that calculates a factorial\nmyfun <- function(x)\n{\n  if (x==1)\n    return (1)\n  else return(x*myfun(x-1))\n}\n\nmyfun(1:10) # does not work\n\n#option1 - with a for loop\nstart_time <- Sys.time()\ny<-0\nfor (i in 1:100)\n  y[i]<-myfun(i)\nend_time <- Sys.time()\nend_time-start_time\ny\nplot(y,type=\"l\")\n\n#option 2 - with apply\nstart_time <- Sys.time()\ny<-sapply(1:100,myfun)\nend_time <- Sys.time()\nend_time-start_time\ny\n\n# selecting a subset from a matrix and applying a function to a column of that subset\n\nsetwd(\"~/iDiv Dropbox/Henrique Pereira/Teaching/Spatial Ecology/Spatial Ecology 2022/2_Lab_assignments\")\nFlorida <- read.csv(\"Florida.csv\")\n\n# number of species for year 1970 and route 20\ntapply(Florida$Abundance,Florida$Route==20 & Florida$Year==1970, length)\n\n# matrix with number of species per route and per year\nout<-tapply(Florida$Abundance,list(Florida$Route,Florida$Year), length)\n\nnames(out[,1])\nplot(out[10,])\nplot(out[20,])\n\n\nshannon<-function(x)\n{\n  p<-x/sum(x)\n  - sum(p*log(p))\n}\n\nout<-tapply(Florida$Abundance,list(Florida$Route,Florida$Year), shannon)\nplot(out[10,])\n\nlibrary(tidyverse)\n\n#our first pipe\nx<-rnorm(1000)\nhist(x)\n\nrnorm(1000) %>%  hist\n\nt<-1:ncol(out)\nmyreg<-lm(out[10,]~t)\nsummary(myreg)\nplot(out[10,])\nabline(myreg)\n\nlm(out[10,]~t) %>% summary \nplot(out[10,])\nlm(out[10,]~t) %>% abline \n\n#ggplot\nmat=cbind(t,out[10,])\ndata(cars)\ncolnames(mat)<-c(\"time\",\"shannon\")\nmat<-as.data.frame(mat)\n\nmyplot <-  ggplot(mat, aes(time,shannon))+\n  geom_point()\nmyplot\n\nmyplot <-  ggplot(mat, aes(time,shannon))+\n  geom_line()\nmyplot\n\ndata(cars)\nmyplot <-  ggplot(cars, aes(speed,dist))+\n  geom_point()+geom_line()\nmyplot\n\ndata(cars)\nmyplot <-  ggplot(cars, aes(speed,dist))+\n  geom_point()+geom_smooth(method=\"lm\")\nmyplot\n\ndata(cars)\nmyplot <-  ggplot(cars, aes(speed,dist))+\n  geom_point()+geom_smooth(method=\"lm\")+scale_x_log10()+scale_y_log10()\nmyplot\n```\n:::\n",
    "supporting": [
      "intro_to_R_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}